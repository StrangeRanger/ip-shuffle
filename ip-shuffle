#!/usr/bin/env bash
#
# This script is used to assign a random IP address to a network interface.
#
# Note:
#   This script can be enhanced by either keeping a list of existing IP addresses that
#   are in use or by checking the ARP table for existing IP addresses.
#
# Limitations:
#   If machines are configured via DHCP, the change of IP addresses will not persist
#   after a reboot.
#
# Valid Operating Systems:
#   - Linux
#   - *BSD
#
# Version: v1.0.0
# License: MIT License
#          Copyright (c) 2024 Hunter T. (StrangeRanger)
#
########################################################################################
####[ Global Variables ]################################################################


###
### [ Configurable Variables ]
### Configure these variables to meet your needs.
###

## Set to true if you want to output the script's output to a file and the console.
readonly C_OUTPUT_TO_FILE=false

## All the variables below should be modified to meet your network configurations.
readonly C_GATEWAY="192.168.1.1"
readonly C_BASE_IP="192.168.1."
readonly C_IP_START=2
readonly C_IP_END=254
readonly C_INTERFACE="enp0s3"  # Used by the Linux VMs in VirtualBox.
#readonly C_INTERFACE="em0"  # Used by FreeBSD VM in VirtualBox.
readonly C_NETMASK="255.255.255.0"
readonly C_NETMASK_CIDR="24"

###
### [ Non-configurable Constants ]
###

C_OS=$(uname -s)
readonly C_OS

C_YELLOW="$(printf '\033[1;33m')"
C_GREEN="$(printf '\033[0;32m')"
C_BLUE="$(printf '\033[0;34m')"
C_CYAN="$(printf '\033[0;36m')"
C_RED="$(printf '\033[1;31m')"
C_NC="$(printf '\033[0m')"
readonly C_YELLOW C_GREEN C_BLUE C_CYAN C_RED C_NC

if [[ $C_OUTPUT_TO_FILE == true ]]; then
    exec > >(
        while IFS= read -r line; do
            printf "[%s] %s\n" "$(date "+%Y-%m-%d %H:%M:%S")" "$line"
        done | tee -a "/var/log/ip-shuffle.log"
    )
    exec 2>&1

    readonly C_NOTE="[INFO] "
    readonly C_INFO="[INFO] "
    readonly C_ERROR="[ERROR] "
    readonly C_WARNING="[WARNING] "
    readonly C_NOTICE="[NOTICE] "
    readonly C_SUCCESS="[INFO] "
else
    readonly C_NOTE="${C_CYAN}[INFO]${C_NC} "
    readonly C_INFO="${C_BLUE}[INFO]${C_NC} "
    readonly C_ERROR="${C_RED}[ERROR]${C_NC} "
    readonly C_WARNING="${C_YELLOW}[WARNING]${C_NC} "
    readonly C_NOTICE="${C_YELLOW}[NOTICE]${C_NC} "
    readonly C_SUCCESS="${C_GREEN}[INFO]${C_NC} "
fi


####[ Functions ]#######################################################################


####
# Generate a random IP address within a range, specified by the network variables above.
#
# GLOBALS:
#   - C_BASE_IP : Used as the base IP to which the random last octet is appended.
#   - C_IP_START : Defines the minimum value for the last octet.
#   - C_IP_END : Defines the maximum value for the last octet.
#   - RANDOM : Generates a random number for the last octet range calculation.
#       - This is a special variable that is automatically set by Bash.
#
# OUTPUTS:
#   The generated IP address.
generate_random_ip() {
    local ip="${C_BASE_IP}$((RANDOM % (C_IP_END - C_IP_START + 1) + C_IP_START))"
    echo "$ip"
}

####
# Check if the given IP address is available on the network.
#
# PARAMETERS:
#   - $1: ip (Required)
#       - The IP address to check.
#
# RETURNS:
#   - 0: If the IP address is not available.
#   - 1: If the IP address is available.
check_ip_availability() {
    local ip="$1"

    echo "${C_INFO}Checking IP address availability of '$ip'..."

    if ping -c 1 -W 1 "$ip" &>/dev/null; then
        echo "${C_WARNING}IP $ip is already in use."
        return 1
    fi

    return 0
}

####
# Validate network configuration.
#
# PARAMETERS:
#   - $1: ip (Required)
#       - The IP address to validate.
#
# RETURNS:
#   - 0: If the IP address is in the same subnet as the gateway.
#   - 1: If the IP address is not in the same subnet as the gateway.
validate_network_config() {
    local ip="$1"

    echo "${C_INFO}Validating network configuration for IP '$ip'..."

    IFS=. read -r i1 i2 i3 i4 <<< "$ip"
    IFS=. read -r g1 g2 g3 g4 <<< "$C_GATEWAY"
    IFS=. read -r m1 m2 m3 m4 <<< "$C_NETMASK"

    # Perform bitwise AND to see if base of IP and gateway match.
    if (( (i1 & m1) != (g1 & m1) )) \
            || (( (i2 & m2) != (g2 & m2) )) \
            || (( (i3 & m3) != (g3 & m3) )) \
            || (( (i4 & m4) != (g4 & m4) )); then
        echo "${C_ERROR}IP address $ip is not in the same subnet as the gateway" \
             "$C_GATEWAY with netmask $C_NETMASK."
        return 1
    fi

    return 0
}

####
# Check gateway reachability.
#
# RETURNS:
#   - 0: If the gateway is reachable.
#   - 1: If the gateway is not reachable.
check_gateway_reachability() {
    echo "${C_INFO}Checking reachability of gateway: $C_GATEWAY"

    if ! ping -c 3 -W 2 "$C_GATEWAY" &>/dev/null; then
        echo "${C_ERROR}Gateway $C_GATEWAY is not reachable."
        return 1
    fi

    return 0
}

####
# Set the IP address of the network interface.
#
# PARAMETERS:
#   - $1: ip (Required)
#       - The IP address to set.
set_ip_address() {
    local ip="$1"

    echo "${C_INFO}Setting IP address to '$ip' on interface '$C_INTERFACE'..."

    {
        if hash ip &>/dev/null; then
            ip addr flush dev "$C_INTERFACE" \
            && ip addr add "$ip"/"$C_NETMASK_CIDR" dev "$C_INTERFACE" \
            && {
                ip route del default \
                || echo "${C_NOTICE}No default route to delete."
            } \
            && ip link set "$C_INTERFACE" up \
            && ip route add default via "$C_GATEWAY"
        else
            case $C_OS in
                *BSD)
                    ifconfig "$C_INTERFACE" inet "$ip" netmask "$C_NETMASK" \
                    && {
                        route delete default \
                        || echo "${C_NOTICE}No default route to delete."
                    } \
                    && route add default "$C_GATEWAY"
                    ;;
                Linux)
                    ifconfig "$C_INTERFACE" "$ip" netmask "$C_NETMASK" \
                    && route add default gw "$C_GATEWAY"
                    ;;
            esac
        fi
    } || {
        echo "${C_ERROR}An error occurred while trying to set a new IP Address."
        reset_network
        clean_exit 1
    }
}

####
# Reset network configurations on Linux and BSD. This is used as a fallback method if
# setting a new IP address fails.
reset_network() {
    echo "${C_NOTE}Resetting network configurations on $C_OS..."
    echo "${C_INFO}Renewing DHCP lease on $C_OS for interface '$C_INTERFACE'..."

    if dhclient "$C_INTERFACE"; then
        echo "${C_SUCCESS}DHCP lease successfully renewed on $C_OS."
    else
        echo "${C_ERROR}Failed to renew DHCP lease on $C_OS."
    fi

}

####
# Generate a random sleep time between the given range.
#
# NOTE:
#   The sleep time is a random number between the min and max values. This is to reduce
#   the likelihood of multiple machines try to assign an IP address at the same time.
#
# PARAMETERS:
#   - $1: min (Optional)
#       - The minimum sleep time.
#       - Default: 1
#   - $2: max (Optional)
#       - The maximum sleep time.
#       - Default: 30
#
# shellcheck disable=SC2120
timed_sleep() {
    local min="${1:-1}"
    local max="${2:-30}"
    local sleep_time=$((RANDOM % (max - min + 1) + min))

    echo "${C_INFO}Sleeping for $sleep_time seconds..."
    sleep $sleep_time
}

####
# Cleanly exit the script.
#
# PARAMETERS:
#   - $1: exit_code (Required)
#       - The type of exit that occurred.
#       - Acceptable values:
#           - 0: Clean exit.
#           - 1: Error occurred.
#           - 130: User interruption.
#           - 143: User interruption.
clean_exit() {
    local exit_code="$1"

    #if [[ $exit_code == "1" ]]; then
    #    echo "${C_ERROR}An error occurred"
    #elif [[ $exit_code == "130" ||  $exit_code == "143" ]]; then
    if [[ $exit_code == "130" ||  $exit_code == "143" ]]; then
        echo ""
        echo "${C_WARNING}Interruption detected"
    fi

    echo "${C_NOTE}Exiting script..."
    exit "$exit_code"
}


####[ Error Traps ]#####################################################################
#### This section sets up error traps to ensure that the script exits gracefully.


trap 'clean_exit "130"' SIGINT
trap 'clean_exit "143"' SIGTERM


####[ Verification ]####################################################################
#### This section ensures that certain conditions are met before the script continues.


if [[ $EUID -ne 0 ]]; then
    echo "${C_ERROR}This script must be run as root."
    clean_exit 1
fi

if ! hash ip &>/dev/null && ! hash ifconfig &>/dev/null; then
    echo "${C_ERROR}ip and ifconfig command not found."
    clean_exit 1
fi

case $C_OS in
    *BSD)
        if ! ifconfig "$C_INTERFACE" &>/dev/null; then
            echo "${C_ERROR}Network interface '$C_INTERFACE' not found."
            clean_exit 1
        fi
        ;;
    Linux)
        if ! ip addr show "$C_INTERFACE" &>/dev/null; then
            echo "${C_ERROR}Network interface '$C_INTERFACE' not found."
            clean_exit 1
        fi
        ;;
    *)
        echo "${C_ERROR}Unsupported operating system."
        clean_exit 1
        ;;
esac


####[ Main ]############################################################################


new_ip="$(generate_random_ip)"

echo "${C_NOTE}Starting IP Shuffle..."

while true; do
    timed_sleep

    if ! check_ip_availability "$new_ip"; then
        echo "${C_INFO}Trying a different IP..."
        new_ip="$(generate_random_ip)"
        continue
    fi

    if ! validate_network_config "$new_ip"; then
        echo "${C_NOTE}Ensure network configurations are correctly set in the script."
        reset_network
        clean_exit 1
    fi

    set_ip_address "$new_ip"

    if ! check_gateway_reachability; then
        echo "${C_NOTE}Ensure the gateway is correctly set in the script."
        reset_network
        clean_exit 1
    fi

    echo "${C_SUCCESS}IP address set successfully."
    break
done
